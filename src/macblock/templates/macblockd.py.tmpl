#!/usr/bin/python3

import ipaddress
import json
import re
import subprocess
import time
from pathlib import Path


def run(cmd: list[str], *, timeout: float | None = None) -> subprocess.CompletedProcess[str]:
    return subprocess.run(cmd, check=False, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=timeout)


def atomic_write_text(path: Path, text: str) -> None:
    tmp = path.with_suffix(path.suffix + ".tmp")
    tmp.write_text(text, encoding="utf-8")
    tmp.replace(path)


_DOMAIN_RE = re.compile(r"^[a-z0-9.-]{1,253}$")


def safe_domain(value: str) -> str | None:
    dom = value.strip().strip(".").lower()
    if not dom or ".." in dom:
        return None
    if not _DOMAIN_RE.match(dom):
        return None
    return dom


def is_forward_ip(value: str) -> bool:
    try:
        ip = ipaddress.ip_address(value)
    except ValueError:
        return False

    if ip.is_loopback:
        return False

    if str(ip) in {"0.0.0.0", "::"}:
        return False

    return True


def load_state(path: Path) -> dict:
    if not path.exists():
        return {}
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return {}


def save_state(path: Path, data: dict) -> None:
    atomic_write_text(path, json.dumps(data, indent=2, sort_keys=True) + "\n")


def list_services() -> list[str]:
    r = run(["/usr/sbin/networksetup", "-listallnetworkservices"], timeout=5)
    if r.returncode != 0:
        return []

    services: list[str] = []
    for raw in (r.stdout or "").splitlines():
        line = raw.rstrip("\n")
        if not line.strip():
            continue
        if line.startswith("An asterisk"):
            continue
        if line.startswith("*"):
            continue
        services.append(line.strip())
    return services


def getinfo_device(service: str) -> str | None:
    r = run(["/usr/sbin/networksetup", "-getinfo", service], timeout=5)
    if r.returncode != 0:
        return None

    for raw in (r.stdout or "").splitlines():
        line = raw.strip()
        if not line.startswith("Device:"):
            continue
        device = line.split(":", 1)[1].strip()
        return device or None

    return None


def parse_exclude(text: str) -> set[str]:
    out: set[str] = set()
    for raw in text.splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        out.add(line)
    return out


def is_managed_service(service: str, device: str | None, exclude: set[str]) -> bool:
    if service in exclude:
        return False

    service_l = service.lower()
    dev = device or ""

    if dev.startswith(("utun", "ppp", "tun", "tap")):
        return False

    if any(x in service_l for x in ("vpn", "tailscale", "wireguard", "openvpn", "anyconnect")):
        return False

    if dev.startswith("en") or dev.startswith("bridge"):
        return True

    if any(x in service_l for x in ("wi-fi", "wifi", "ethernet", "usb", "thunderbolt")):
        return True

    return False


def compute_managed_services(exclude: set[str]) -> list[str]:
    out: list[str] = []
    for name in list_services():
        dev = getinfo_device(name)
        if not is_managed_service(name, dev, exclude):
            continue
        out.append(name)
    return sorted(out, key=lambda x: x.lower())


def get_dns_servers(service: str) -> list[str] | None:
    r = run(["/usr/sbin/networksetup", "-getdnsservers", service], timeout=5)
    if r.returncode != 0:
        return None

    out = (r.stdout or "").strip()
    if not out:
        return None
    if "There aren't any DNS Servers" in out:
        return None

    servers: list[str] = []
    for raw in out.splitlines():
        ip = raw.strip()
        if ip:
            servers.append(ip)
    return servers or None


def get_search_domains(service: str) -> list[str] | None:
    r = run(["/usr/sbin/networksetup", "-getsearchdomains", service], timeout=5)
    if r.returncode != 0:
        return None

    out = (r.stdout or "").strip()
    if not out:
        return None
    if "There aren't any Search Domains" in out:
        return None

    domains: list[str] = []
    for raw in out.splitlines():
        dom = raw.strip().strip(".")
        if dom:
            domains.append(dom)
    return domains or None


def set_dns_servers(service: str, servers: list[str] | None) -> None:
    if servers:
        run(["/usr/sbin/networksetup", "-setdnsservers", service, *servers], timeout=10)
    else:
        run(["/usr/sbin/networksetup", "-setdnsservers", service, "Empty"], timeout=10)


def set_search_domains(service: str, domains: list[str] | None) -> None:
    if domains:
        run(["/usr/sbin/networksetup", "-setsearchdomains", service, *domains], timeout=10)
    else:
        run(["/usr/sbin/networksetup", "-setsearchdomains", service, "Empty"], timeout=10)


def read_dhcp_nameservers(device: str) -> list[str]:
    if not device:
        return []

    r = run(["/usr/sbin/ipconfig", "getoption", device, "domain_name_server"], timeout=5)
    if r.returncode != 0:
        return []

    ips: list[str] = []
    for token in (r.stdout or "").strip().split():
        if is_forward_ip(token) and token not in ips:
            ips.append(token)

    return ips


def parse_scutil_dns(text: str) -> dict[str, list[str]]:
    current_domain: str | None = None
    per_domain: dict[str, list[str]] = {}

    in_resolver = False

    for raw_line in text.splitlines():
        line = raw_line.strip()
        if not line:
            continue

        if re.match(r"resolver #\d+", line):
            in_resolver = True
            current_domain = None
            continue

        if not in_resolver:
            continue

        if line.startswith("domain"):
            parts = line.split(":", 1)
            if len(parts) == 2:
                dom = safe_domain(parts[1])
                if dom:
                    current_domain = dom
                    per_domain.setdefault(dom, [])
            continue

        if line.startswith("nameserver"):
            parts = line.split(":", 1)
            if len(parts) != 2:
                continue

            ip = parts[1].strip()
            if not is_forward_ip(ip):
                continue
            if current_domain is None:
                continue

            lst = per_domain.setdefault(current_domain, [])
            if ip not in lst:
                lst.append(ip)

    return per_domain


def render_upstream_conf(defaults: list[str], per_domain: dict[str, list[str]]) -> str:
    if not defaults:
        defaults = ["1.1.1.1", "8.8.8.8"]

    lines: list[str] = []
    for ip in defaults:
        if is_forward_ip(ip):
            lines.append(f"server={ip}")

    for dom, ips in sorted(per_domain.items()):
        safe_dom = safe_domain(dom)
        if not safe_dom:
            continue
        for ip in ips:
            if is_forward_ip(ip):
                lines.append(f"server=/{safe_dom}/{ip}")

    return "\n".join(lines) + "\n"


def update_upstreams(state: dict, out_path: Path) -> None:
    exclude = set()
    exclude_path = Path("{{DNS_EXCLUDE_SERVICES_FILE}}")
    if exclude_path.exists():
        try:
            exclude = parse_exclude(exclude_path.read_text(encoding="utf-8"))
        except Exception:
            exclude = set()

    managed_services = compute_managed_services(exclude)

    devices: list[str] = []
    for name in managed_services:
        dev = getinfo_device(name)
        if dev and dev not in devices:
            devices.append(dev)

    defaults: list[str] = []
    for dev in devices:
        for ip in read_dhcp_nameservers(dev):
            if ip not in defaults:
                defaults.append(ip)

    dns_backup = state.get("dns_backup")
    if isinstance(dns_backup, dict):
        for service in managed_services:
            cfg = dns_backup.get(service)
            if not isinstance(cfg, dict):
                continue

            servers = cfg.get("dns")
            if isinstance(servers, list):
                for ip in servers:
                    if isinstance(ip, str) and is_forward_ip(ip) and ip not in defaults:
                        defaults.append(ip)

            dhcp_servers = cfg.get("dhcp")
            if isinstance(dhcp_servers, list):
                for ip in dhcp_servers:
                    if isinstance(ip, str) and is_forward_ip(ip) and ip not in defaults:
                        defaults.append(ip)

    r = run(["/usr/sbin/scutil", "--dns"], timeout=10)
    per_domain = parse_scutil_dns(r.stdout or "") if r.returncode == 0 else {}

    conf = render_upstream_conf(defaults, per_domain)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    atomic_write_text(out_path, conf)


def hup_dnsmasq(pid_path: Path) -> None:
    if not pid_path.exists():
        return
    try:
        pid = int(pid_path.read_text(encoding="utf-8").strip())
    except Exception:
        return
    if pid <= 1:
        return
    run(["/bin/kill", "-HUP", str(pid)], timeout=2)


def apply_state(state_path: Path, upstream_out: Path, dnsmasq_pid: Path) -> None:
    state = load_state(state_path)

    enabled = bool(state.get("enabled") or False)

    resume_at_raw = state.get("resume_at_epoch")
    resume_at: int | None
    if resume_at_raw is None:
        resume_at = None
    else:
        try:
            resume_at = int(resume_at_raw)
        except Exception:
            resume_at = None

    now = int(time.time())
    paused = resume_at is not None and resume_at > now

    if resume_at is not None and not paused:
        state["resume_at_epoch"] = None

    exclude = set()
    exclude_path = Path("{{DNS_EXCLUDE_SERVICES_FILE}}")
    if exclude_path.exists():
        try:
            exclude = parse_exclude(exclude_path.read_text(encoding="utf-8"))
        except Exception:
            exclude = set()

    services = compute_managed_services(exclude)

    dns_backup = state.get("dns_backup")
    if not isinstance(dns_backup, dict):
        dns_backup = {}
        state["dns_backup"] = dns_backup

    if enabled and not paused:
        for service in services:
            if service not in dns_backup:
                current_dns = get_dns_servers(service)
                if current_dns != ["127.0.0.1"]:
                    dev = getinfo_device(service)
                    dhcp = read_dhcp_nameservers(dev or "")
                    dns_backup[service] = {
                        "dns": current_dns,
                        "search": get_search_domains(service),
                        "dhcp": dhcp or None,
                    }

            set_dns_servers(service, ["127.0.0.1"])

        state["managed_services"] = services

    else:
        managed = state.get("managed_services")
        to_restore = managed if isinstance(managed, list) else services

        for service in to_restore:
            cfg = dns_backup.get(service)
            if not isinstance(cfg, dict):
                continue

            dns = cfg.get("dns") if isinstance(cfg.get("dns"), list) else None
            search = cfg.get("search") if isinstance(cfg.get("search"), list) else None
            set_dns_servers(service, dns)
            set_search_domains(service, search)

    save_state(state_path, state)

    update_upstreams(state, upstream_out)
    hup_dnsmasq(dnsmasq_pid)


def seconds_until_next_event(state: dict) -> float | None:
    enabled = bool(state.get("enabled") or False)
    if not enabled:
        return None

    resume_at_raw = state.get("resume_at_epoch")
    if resume_at_raw is None:
        return None

    try:
        resume_at = int(resume_at_raw)
    except Exception:
        return None

    now = int(time.time())
    if resume_at <= now:
        return 0

    return float(resume_at - now)


def main() -> int:
    state_path = Path("{{SYSTEM_STATE_FILE}}")
    upstream_out = Path("{{UPSTREAM_OUT}}")
    dnsmasq_pid = Path("{{DNSMASQ_PID_FILE}}")

    while True:
        apply_state(state_path, upstream_out, dnsmasq_pid)

        state = load_state(state_path)
        timeout = seconds_until_next_event(state)

        try:
            run(["/usr/bin/notifyutil", "-w", "com.apple.system.config.network_change"], timeout=timeout)
        except subprocess.TimeoutExpired:
            continue


if __name__ == "__main__":
    raise SystemExit(main())
