#!/usr/bin/python3

import json
import re
import subprocess
from pathlib import Path


def run(cmd: list[str]) -> subprocess.CompletedProcess[str]:
    return subprocess.run(cmd, check=False, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)


def list_services() -> list[str]:
    r = run(["/usr/sbin/networksetup", "-listallnetworkservices"])
    if r.returncode != 0:
        return []

    services: list[str] = []
    for raw in (r.stdout or "").splitlines():
        line = raw.rstrip("\n")
        if not line.strip():
            continue
        if line.startswith("An asterisk"):
            continue
        if line.startswith("*"):
            continue
        services.append(line.strip())
    return services


def getinfo_device(service: str) -> str | None:
    r = run(["/usr/sbin/networksetup", "-getinfo", service])
    if r.returncode != 0:
        return None

    for raw in (r.stdout or "").splitlines():
        line = raw.strip()
        if not line.startswith("Device:"):
            continue
        device = line.split(":", 1)[1].strip()
        return device or None

    return None


def parse_exclude(text: str) -> set[str]:
    out: set[str] = set()
    for raw in text.splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        out.add(line)
    return out


def is_managed_service(service: str, device: str | None, exclude: set[str]) -> bool:
    if service in exclude:
        return False

    service_l = service.lower()
    dev = device or ""

    if dev.startswith(("utun", "ppp", "tun", "tap")):
        return False

    if any(x in service_l for x in ("vpn", "tailscale", "wireguard", "openvpn", "anyconnect")):
        return False

    if dev.startswith("en") or dev.startswith("bridge"):
        return True

    if any(x in service_l for x in ("wi-fi", "wifi", "ethernet", "usb", "thunderbolt")):
        return True

    return False


def parse_scutil_dns(text: str) -> tuple[list[str], dict[str, list[str]]]:
    current_domain: str | None = None
    defaults: list[str] = []
    per_domain: dict[str, list[str]] = {}

    in_resolver = False

    for raw_line in text.splitlines():
        line = raw_line.strip()
        if not line:
            continue

        m = re.match(r"resolver #\d+", line)
        if m:
            in_resolver = True
            current_domain = None
            continue

        if not in_resolver:
            continue

        if line.startswith("domain"):
            parts = line.split(":", 1)
            if len(parts) == 2:
                dom = parts[1].strip().strip(".")
                if dom:
                    current_domain = dom
                    per_domain.setdefault(dom, [])
            continue

        if line.startswith("nameserver"):
            parts = line.split(":", 1)
            if len(parts) != 2:
                continue
            ip = parts[1].strip()
            if ip in {"127.0.0.1", "0.0.0.0"}:
                continue
            if current_domain is None:
                if ip not in defaults:
                    defaults.append(ip)
            else:
                lst = per_domain.setdefault(current_domain, [])
                if ip not in lst:
                    lst.append(ip)

    return defaults, per_domain


def render_upstream_conf(defaults: list[str], per_domain: dict[str, list[str]]) -> str:
    # dnsmasq returns REFUSED for recursive queries if no upstreams exist.
    # Ensure we always have at least one default upstream.
    if not defaults:
        defaults = ["1.1.1.1", "8.8.8.8"]

    lines: list[str] = []
    for ip in defaults:
        lines.append(f"server={ip}")

    for dom, ips in sorted(per_domain.items()):
        for ip in ips:
            lines.append(f"server=/{dom}/{ip}")

    return "\n".join(lines) + "\n"


_IP_RE = re.compile(r"^(?:\d{1,3}\.){3}\d{1,3}$")


def read_dhcp_nameservers(device: str) -> list[str]:
    if not device:
        return []
    r = run(["/usr/sbin/ipconfig", "getoption", device, "domain_name_server"])
    if r.returncode != 0:
        return []

    ips: list[str] = []
    for token in (r.stdout or "").strip().split():
        if _IP_RE.match(token) and token not in ips and token != "127.0.0.1":
            ips.append(token)
    return ips


def _write_resolvers(resolver_dir: Path, domains: list[str]) -> None:
    resolver_dir.mkdir(parents=True, exist_ok=True)
    for dom in domains:
        p = resolver_dir / dom
        p.write_text("# macblock\nnameserver 127.0.0.1\n", encoding="utf-8")


def _safe_remove_old_resolvers(resolver_dir: Path, to_remove: list[str]) -> None:
    for dom in to_remove:
        p = resolver_dir / dom
        if not p.exists():
            continue
        try:
            head = p.read_text(encoding="utf-8", errors="ignore")[:64]
        except Exception:
            continue
        if not head.startswith("# macblock"):
            continue
        try:
            p.unlink()
        except Exception:
            pass


def main() -> int:
    state_path = Path("{{SYSTEM_STATE_FILE}}")
    out_path = Path("{{UPSTREAM_OUT}}")
    pid_path = Path("{{DNSMASQ_PID_FILE}}")
    exclude_path = Path("{{DNS_EXCLUDE_SERVICES_FILE}}")
    resolver_dir = Path("{{RESOLVER_DIR}}")

    out_path.parent.mkdir(parents=True, exist_ok=True)

    data = {}
    if state_path.exists():
        try:
            data = json.loads(state_path.read_text(encoding="utf-8"))
        except Exception:
            data = {}

    exclude = set()
    if exclude_path.exists():
        try:
            exclude = parse_exclude(exclude_path.read_text(encoding="utf-8"))
        except Exception:
            exclude = set()

    devices: list[str] = []
    for name in list_services():
        dev = getinfo_device(name)
        if not is_managed_service(name, dev, exclude):
            continue
        if dev and dev not in devices:
            devices.append(dev)

    defaults: list[str] = []
    for dev in devices:
        for ip in read_dhcp_nameservers(dev):
            if ip not in defaults:
                defaults.append(ip)

    dns_backup = data.get("dns_backup")
    if isinstance(dns_backup, dict):
        managed_services = data.get("managed_services")
        managed = managed_services if isinstance(managed_services, list) else []

        for service in managed:
            if not isinstance(service, str) or not service:
                continue
            cfg = dns_backup.get(service)
            if not isinstance(cfg, dict):
                continue
            servers = cfg.get("dns")
            if isinstance(servers, list):
                for ip in servers:
                    if not isinstance(ip, str) or not ip:
                        continue
                    if ip == "127.0.0.1":
                        continue
                    if ip not in defaults:
                        defaults.append(ip)
                continue

            dhcp_servers = cfg.get("dhcp")
            if isinstance(dhcp_servers, list):
                for ip in dhcp_servers:
                    if not isinstance(ip, str) or not ip:
                        continue
                    if ip == "127.0.0.1":
                        continue
                    if ip not in defaults:
                        defaults.append(ip)

    r = run(["/usr/sbin/scutil", "--dns"])
    if r.returncode != 0:
        return r.returncode

    _, per_domain = parse_scutil_dns(r.stdout)

    conf = render_upstream_conf(defaults, per_domain)

    tmp = out_path.with_suffix(out_path.suffix + ".tmp")
    tmp.write_text(conf, encoding="utf-8")
    tmp.replace(out_path)

    domains = sorted([d for d in per_domain.keys() if d])

    prev = data.get("resolver_domains")
    prev_domains = [x for x in prev if isinstance(x, str) and x] if isinstance(prev, list) else []

    _write_resolvers(resolver_dir, domains)
    _safe_remove_old_resolvers(resolver_dir, [d for d in prev_domains if d not in domains])

    data["resolver_domains"] = domains

    if state_path.exists():
        tmp_state = state_path.with_suffix(state_path.suffix + ".tmp")
        tmp_state.write_text(json.dumps(data, indent=2, sort_keys=True) + "\n", encoding="utf-8")
        tmp_state.replace(state_path)

    if pid_path.exists():
        try:
            p = int(pid_path.read_text(encoding="utf-8").strip())
        except Exception:
            return 0
        run(["/bin/kill", "-HUP", str(p)])

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
